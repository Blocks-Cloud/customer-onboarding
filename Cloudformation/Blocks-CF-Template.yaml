AWSTemplateFormatVersion: '2010-09-09'
Description: 'Blocks - CloudOptimisation - CUR 2.0 to S3 + comprehensive cross-account role + best-effort Support backfill. Deploy in us-east-1.'

Parameters:
  UseExistingBucket:
    Type: String
    Default: 'FALSE'
    AllowedValues: ['TRUE','FALSE']
    Description: 'TRUE to use an already-existing bucket'
  ExistingBucketName:
    Type: String
    Default: ''
    Description: 'Exact name of the pre-existing bucket (required if UseExistingBucket=TRUE)'
  BucketNamePrefix:
    Type: String
    Default: 'blocks-cur-data'
    Description: 'Prefix if creating a new bucket; stack suffixes with account and region'
  ExportName:
    Type: String
    Default: 'hourly-cost-usage-cur2'
    Description: 'Base name for the Data Exports (CUR 2.0) export; template appends account/region/stack to avoid collisions'
  TimeGranularity:
    Type: String
    Default: 'HOURLY'
    AllowedValues: ['HOURLY','DAILY','MONTHLY']
    Description: 'CUR granularity'
  IncludeResources:
    Type: String
    Default: 'TRUE'
    AllowedValues: ['TRUE','FALSE']
    Description: 'Include resource IDs'
  BackfillMonths:
    Type: Number
    Default: 12
    MinValue: 1
    MaxValue: 36
    Description: 'Months of historical data to request via Support'
  SupportSeverity:
    Type: String
    Default: 'low'
    AllowedValues: ['low','normal','high','urgent','critical']
    Description: 'Support case severity'
  BlocksExternalAccountId:
    Type: String
    Default: "503132503926"
    Description: 'Your AWS account ID (12 digits) that will assume the role'
  ExternalId:
    Type: String
    NoEcho: true
    Default: "blocks-shared-secret"
    Description: 'Shared secret required in sts:AssumeRole (set per customer if you want)'
  KmsKeyArn:
    Type: String
    Default: ''
    Description: 'Optional CMK ARN for bucket encryption; if set, also update the CMK key policy to allow S3 and bcm-data-exports'
  StackSetName:
    Type: String
    Default: 'Blocks-Subaccount-IAM-Roles'
    Description: 'The name for the CloudFormation StackSet that deploys IAM roles to sub-accounts.'
  SubAccountsStacksetTemplateUrl:
    Type: String
    Default: 'https://blocks-cf-templates.s3.eu-north-1.amazonaws.com/Blocks-CF-Subaccounts-Template.yaml'
    Description: 'The URL for the StackSet template that creates IAM roles in sub-accounts.'
  MaxConcurrentCount:
    Type: Number
    Default: 20
    Description: 'The maximum number of accounts to operate on at the same time for the StackSet.'
  FailureToleranceCount:
    Type: Number
    Default: 5
    Description: 'The number of accounts that can fail before stopping the StackSet operation.'
  StackSetLambdaVersion:
    Type: Number
    Default: 1
    Description: 'A version number for the StackSet Lambda. Increment this to force the lambda to run on stack update.'
Conditions:
  CreateBucket: !Equals [!Ref UseExistingBucket, 'FALSE']
  HasKms: !Not [!Equals [!Ref KmsKeyArn, '']]

Resources:
  CURBucket:
    Type: AWS::S3::Bucket
    Condition: CreateBucket
    Properties:
      BucketName: !Sub '${BucketNamePrefix}-${AWS::AccountId}-${AWS::Region}'
      OwnershipControls:
        Rules: [{ ObjectOwnership: BucketOwnerEnforced }]
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Status: Enabled
            ExpirationInDays: 7
            NoncurrentVersionExpirationInDays: 7
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 7
      VersioningConfiguration: { Status: Enabled }
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - !If
            - HasKms
            - { ServerSideEncryptionByDefault: { SSEAlgorithm: aws:kms, KMSMasterKeyID: !Ref KmsKeyArn } }
            - { ServerSideEncryptionByDefault: { SSEAlgorithm: AES256 } }

  CURBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName]
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowBCMDataExportsPut
            Effect: Allow
            Principal: { Service: bcm-data-exports.amazonaws.com }
            Action: s3:PutObject
            Resource:
              !Sub
                - 'arn:${AWS::Partition}:s3:::${B}/*'
                - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }
            Condition:
              StringEquals: { aws:SourceAccount: !Ref AWS::AccountId }
              StringLike:
                aws:SourceArn: !Sub 'arn:${AWS::Partition}:bcm-data-exports:us-east-1:${AWS::AccountId}:export/*'
          - Sid: AllowBCMDataExportsBucketMeta
            Effect: Allow
            Principal: { Service: bcm-data-exports.amazonaws.com }
            Action:
              - s3:GetBucketAcl
              - s3:GetBucketPolicy
              - s3:GetBucketLocation
              - s3:ListBucket
            Resource:
              !Sub
                - 'arn:${AWS::Partition}:s3:::${B}'
                - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }
            Condition:
              StringEquals: { aws:SourceAccount: !Ref AWS::AccountId }
              StringLike:
                aws:SourceArn: !Sub 'arn:${AWS::Partition}:bcm-data-exports:us-east-1:${AWS::AccountId}:export/*'
          - Sid: AllowReadRoleGetObject
            Effect: Allow
            Principal:
              AWS: !GetAtt BlocksReadRole.Arn
            Action: ['s3:GetObject']
            Resource:
              !Sub
                - 'arn:${AWS::Partition}:s3:::${B}/cur2/*'
                - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }

  Cur20Export:
    Type: AWS::BCMDataExports::Export
    DependsOn: CURBucketPolicy
    Properties:
      Export:
        Name: !Sub '${ExportName}-${AWS::AccountId}'
        Description: 'CUR 2.0 export to S3 (Parquet), hourly with resource IDs'
        DataQuery:
          QueryStatement: |
            SELECT bill_bill_type, 
              bill_billing_entity, 
              bill_billing_period_end_date, 
              bill_billing_period_start_date, 
              bill_invoice_id, 
              bill_invoicing_entity, 
              bill_payer_account_id,
              bill_payer_account_name, 
              cost_category, 
              discount, 
              discount_bundled_discount, 
              discount_total_discount, 
              identity_line_item_id, 
              identity_time_interval, 
              line_item_availability_zone, 
              line_item_blended_cost, 
              line_item_blended_rate, 
              line_item_currency_code, 
              line_item_legal_entity, 
              line_item_line_item_description, 
              line_item_line_item_type, 
              line_item_net_unblended_cost, 
              line_item_net_unblended_rate, 
              line_item_normalization_factor, 
              line_item_normalized_usage_amount, 
              line_item_operation, 
              line_item_product_code, 
              line_item_resource_id, 
              line_item_tax_type, 
              line_item_unblended_cost, 
              line_item_unblended_rate, 
              line_item_usage_account_id, 
              line_item_usage_account_name, 
              line_item_usage_amount, 
              line_item_usage_end_date, 
              line_item_usage_start_date, 
              line_item_usage_type, 
              pricing_currency, 
              pricing_lease_contract_length, 
              pricing_offering_class, 
              pricing_public_on_demand_cost, 
              pricing_public_on_demand_rate, 
              pricing_purchase_option, 
              pricing_rate_code, 
              pricing_rate_id, 
              pricing_term, 
              pricing_unit, 
              product, 
              product_comment, 
              product_fee_code, 
              product_fee_description, 
              product_from_location, 
              product_from_location_type, 
              product_from_region_code, 
              product_instance_family,
              product_instance_type, 
              product_instancesku, 
              product_location, 
              product_location_type,
              product_operation, 
              product_pricing_unit, 
              product_product_family, 
              product_region_code,
              product_servicecode,
              product_sku,
              product_to_location, 
              product_to_location_type,
              product_to_region_code, 
              product_usagetype, 
              reservation_amortized_upfront_cost_for_usage, 
              reservation_amortized_upfront_fee_for_billing_period, 
              reservation_availability_zone, 
              reservation_effective_cost, 
              reservation_end_time, 
              reservation_modification_status, 
              reservation_net_amortized_upfront_cost_for_usage, 
              reservation_net_amortized_upfront_fee_for_billing_period, 
              reservation_net_effective_cost, 
              reservation_net_recurring_fee_for_usage,
              reservation_net_unused_amortized_upfront_fee_for_billing_period, 
              reservation_net_unused_recurring_fee, reservation_net_upfront_value, 
              reservation_normalized_units_per_reservation, 
              reservation_number_of_reservations,
              reservation_recurring_fee_for_usage, 
              reservation_reservation_a_r_n, 
              reservation_start_time,
              reservation_subscription_id,
              reservation_total_reserved_normalized_units, 
              reservation_total_reserved_units, 
              reservation_units_per_reservation, 
              reservation_unused_amortized_upfront_fee_for_billing_period,
              reservation_unused_normalized_unit_quantity, 
              reservation_unused_quantity,
              reservation_unused_recurring_fee, 
              reservation_upfront_value, 
              resource_tags, 
              savings_plan_amortized_upfront_commitment_for_billing_period, 
              savings_plan_end_time, savings_plan_instance_type_family, 
              savings_plan_net_amortized_upfront_commitment_for_billing_period, 
              savings_plan_net_recurring_commitment_for_billing_period, 
              savings_plan_net_savings_plan_effective_cost, 
              savings_plan_offering_type, 
              savings_plan_payment_option,
              savings_plan_purchase_term, 
              savings_plan_recurring_commitment_for_billing_period, 
              savings_plan_region, 
              savings_plan_savings_plan_a_r_n,
              savings_plan_savings_plan_effective_cost,
              savings_plan_savings_plan_rate, 
              savings_plan_start_time, 
              savings_plan_total_commitment_to_date,
              savings_plan_used_commitment, 
              split_line_item_actual_usage, 
              split_line_item_net_split_cost, 
              split_line_item_net_unused_cost, 
              split_line_item_parent_resource_id, 
              split_line_item_public_on_demand_split_cost,
              split_line_item_public_on_demand_unused_cost, 
              split_line_item_reserved_usage, 
              split_line_item_split_cost, 
              split_line_item_split_usage,
              split_line_item_split_usage_ratio, 
              split_line_item_unused_cost
            FROM COST_AND_USAGE_REPORT
          TableConfigurations:
            COST_AND_USAGE_REPORT:
              INCLUDE_MANUAL_DISCOUNT_COMPATIBILITY: 'FALSE'
              TIME_GRANULARITY: !Ref TimeGranularity
              INCLUDE_RESOURCES: !Ref IncludeResources
              INCLUDE_SPLIT_COST_ALLOCATION_DATA: 'TRUE'
        DestinationConfigurations:
          S3Destination:
            S3Bucket: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName]
            S3Prefix: 'cur2'
            S3Region: !Ref AWS::Region
            S3OutputConfigurations:
              Compression: PARQUET
              Format: PARQUET
              OutputType: CUSTOM
              Overwrite: OVERWRITE_REPORT
        RefreshCadence: { Frequency: SYNCHRONOUS }

  BlocksCustomResourceExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::AccountId}-Blocks-Lambda-StackSet-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CustomResourcePermissions
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
              - Effect: Allow
                Action:
                  - support:CreateCase
                  - support:DescribeServices
                  - support:DescribeSeverityLevels
                  - cloudformation:CreateStackSet
                  - cloudformation:UpdateStackSet
                  - cloudformation:DeleteStackSet
                  - cloudformation:CreateStackInstances
                  - cloudformation:UpdateStackInstances
                  - cloudformation:DeleteStackInstances
                  - cloudformation:DescribeStackSet
                  - cloudformation:DescribeStackSetOperation
                  - cloudformation:ListStackInstances
                  - iam:PassRole
                Resource: "*"
              - Effect: Allow
                Action:
                  - organizations:ListRoots
                  - organizations:ListOrganizationalUnitsForParent
                  - organizations:ListAccounts
                  - organizations:ListAccountsForParent
                  - organizations:DescribeOrganization
                Resource: "*"

  BackfillRequesterFn:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt BlocksCustomResourceExecutionRole.Arn
      Timeout: 120
      FunctionName: !Sub '${AWS::StackName}-BackfillRequesterFn'
      Environment:
        Variables:
          EXPORT_NAME: !Ref ExportName
          BACKFILL_MONTHS: !Ref BackfillMonths
          SEVERITY: !Ref SupportSeverity
      Code:
        ZipFile: |
          import boto3, json, os, urllib.request, logging
          from botocore.exceptions import ClientError
          log = logging.getLogger()
          log.setLevel(logging.INFO)

          def send_response(event, context, status, reason=None, data=None, phys_id=None):
              try:
                  data = data or {}
                  if 'CaseId' not in data:
                      data['CaseId'] = ''
                  body = json.dumps({
                      'Status': status,
                      'Reason': (reason or 'OK')[:4096],
                      'PhysicalResourceId': phys_id or context.log_stream_name,
                      'StackId': event['StackId'],
                      'RequestId': event['RequestId'],
                      'LogicalResourceId': event['LogicalResourceId'],
                      'Data': data
                  }).encode('utf-8')
                  req = urllib.request.Request(event['ResponseURL'], data=body, method='PUT',
                                               headers={'content-type':'', 'content-length': str(len(body))})
                  with urllib.request.urlopen(req) as f:
                      f.read()
              except Exception:
                  log.exception("Failed sending CFN response")

          def handler(event, context):
              log.info("Event: %s", json.dumps(event))

              # Handle Delete event separately and exit early.
              if event['RequestType'] == 'Delete':
                  log.info("RequestType is Delete. No action to perform.")
                  send_response(event, context, 'SUCCESS', reason='No action on delete')
                  return

              # Handle Create/Update events
              status, reason, data, phys = 'SUCCESS', 'OK', {'CaseId': ''}, None
              try:
                  support = boto3.client('support', region_name='us-east-1')
                  export_name = os.environ['EXPORT_NAME']
                  months = int(os.environ.get('BACKFILL_MONTHS','12'))
                  severity = os.environ.get('SEVERITY','low')
                  try:
                      svc_code = "service-cost-and-usage-report-cur"
                      cat_code = "backfill-a-report"
                      issue_type = "customer-service"
                      language = "en"
                      subject = f"Request backfill for CUR 2.0 export '{export_name}'"
                      body = f"Please backfill {months} months of historical data into CUR 2.0 export '{export_name}'."
                      resp = support.create_case(
                          subject=subject,
                          serviceCode=svc_code,
                          severityCode=severity,
                          categoryCode=cat_code,
                          communicationBody=body,
                          language=language,
                          issueType=issue_type,
                      )
                      phys = resp.get('caseId','unknown')
                      data.update({'CaseId': phys, 'BackfillRequested': True})
                  except ClientError as ce:
                      code = ce.response.get('Error',{}).get('Code','')
                      if code in ('SubscriptionRequiredException','AccessDeniedException') or 'AccessDenied' in code:
                          reason = f'Support API not available ({code}). Skipping backfill request.'
                          data.update({'BackfillRequested': False, 'Reason': reason})
                      else:
                          status = 'FAILED'
                          reason = f'Unexpected Support API error: {code}'
              except Exception as e:
                  status = 'FAILED'
                  reason = f'Unhandled error: {e}'
              finally:
                  send_response(event, context, status, reason, data, phys)

  RequestBackfill:
    Type: Custom::RequestCurBackfill
    DependsOn: Cur20Export
    Properties:
      ServiceToken: !GetAtt BackfillRequesterFn.Arn
      ExportName: !Ref ExportName
      BackfillMonths: !Ref BackfillMonths
      Severity: !Ref SupportSeverity

  StackSetLambda:
      Type: AWS::Lambda::Function
      Properties:
        Handler: index.handler
        Runtime: python3.11
        Timeout: 900
        Role: !GetAtt BlocksCustomResourceExecutionRole.Arn
        FunctionName: !Sub '${AWS::StackName}-StackSet'
        Environment:
          Variables:
            STACKSET_NAME: !Ref StackSetName
            SUB_ACCOUNTS_STACKSET_TEMPLATE_URL: !Ref SubAccountsStacksetTemplateUrl
            MAX_CONCURRENT_COUNT: !Ref MaxConcurrentCount
            FAILURE_TOLERANCE_COUNT: !Ref FailureToleranceCount
        Code:
          ZipFile: |
            import json, boto3, urllib3, traceback, os, time
            from botocore.exceptions import ClientError
            http = urllib3.PoolManager()

            def send_response(event, context, status, data=None, reason=None, physical_resource_id=None):
                response_body = {
                    'Status': status,
                    'Reason': reason or f'See CloudWatch Log Stream: {context.log_stream_name}',
                    'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                    'StackId': event['StackId'],
                    'RequestId': event['RequestId'],
                    'LogicalResourceId': event['LogicalResourceId'],
                    'Data': data or {}
                }
                json_body = json.dumps(response_body)
                print("Sending response:", json_body)
                http.request('PUT', event['ResponseURL'], body=json_body, headers={'Content-Type': ''})

            def wait_for_operation(cf, stackset_name, operation_id):
                """Waits for a StackSet operation to complete."""
                while True:
                    try:
                        response = cf.describe_stack_set_operation(
                            StackSetName=stackset_name,
                            OperationId=operation_id
                        )
                        status = response['StackSetOperation']['Status']
                        print(f"Operation {operation_id} status: {status}")
                        if status in ['SUCCEEDED', 'FAILED', 'STOPPED']:
                            return status
                        time.sleep(15)
                    except Exception as e:
                        print(f"Error checking operation status: {e}")
                        time.sleep(15)

            def handler(event, context):
                print("Event received:", json.dumps(event))
                cf = boto3.client('cloudformation')
                org = boto3.client('organizations')
                
                physical_resource_id = event.get('PhysicalResourceId')

                try:
                    request_type = event['RequestType']

                    if request_type == 'Create' and not physical_resource_id:
                        physical_resource_id = f"StackSet-{event['StackId']}-{event['LogicalResourceId']}"

                    stackset_name = os.environ['STACKSET_NAME']
                    template_url = os.environ['SUB_ACCOUNTS_STACKSET_TEMPLATE_URL']
                    max_concurrent = int(os.environ['MAX_CONCURRENT_COUNT'])
                    failure_tolerance = int(os.environ['FAILURE_TOLERANCE_COUNT'])

                    operation_preferences = {
                        'FailureToleranceCount': failure_tolerance,
                        'MaxConcurrentCount': max_concurrent
                    }

                    if request_type == 'Create' or request_type == 'Update':
                        operation_id = None
                        try:
                            cf.describe_stack_set(StackSetName=stackset_name)
                            # UPDATE PATH
                            print("StackSet exists, updating...")
                            update_set_response = cf.update_stack_set(
                                StackSetName=stackset_name,
                                TemplateURL=template_url,
                                PermissionModel='SERVICE_MANAGED',
                                Capabilities=['CAPABILITY_NAMED_IAM'],
                                AutoDeployment={
                                    'Enabled': True,
                                    'RetainStacksOnAccountRemoval': False
                                },
                                OperationPreferences=operation_preferences
                            )
                            if 'OperationId' in update_set_response:
                                print(f"Update stack set definition operation started: {update_set_response['OperationId']}")
                                status = wait_for_operation(cf, stackset_name, update_set_response['OperationId'])
                                if status != 'SUCCEEDED':
                                    raise Exception(f"StackSet definition update failed with status: {status}")
                            
                            root_id = org.list_roots()['Roots'][0]['Id']
                            paginator = cf.get_paginator('list_stack_instances')
                            pages = paginator.paginate(StackSetName=stackset_name)
                            summaries = []
                            for page in pages:
                                summaries.extend(page['Summaries'])

                            if not summaries:
                                print("No stack instances found, creating them...")
                                create_instances_response = cf.create_stack_instances(
                                    StackSetName=stackset_name,
                                    DeploymentTargets={'OrganizationalUnitIds': [root_id]},
                                    Regions=['us-east-1'],
                                    OperationPreferences=operation_preferences
                                )
                                operation_id = create_instances_response['OperationId']
                                print(f"Create instances operation started: {operation_id}")
                            else:
                                print("Existing stack instances found, updating them...")
                                regions = list(set(inst['Region'] for inst in summaries))
                                print(f"Updating instances in regions: {regions}")
                                update_instances_response = cf.update_stack_instances(
                                    StackSetName=stackset_name,
                                    DeploymentTargets={'OrganizationalUnitIds': [root_id]},
                                    Regions=regions,
                                    OperationPreferences=operation_preferences
                                )
                                operation_id = update_instances_response['OperationId']
                                print(f"Update instances operation started: {operation_id}")

                        except cf.exceptions.StackSetNotFoundException:
                            # CREATE PATH
                            print("Creating StackSet...")
                            cf.create_stack_set(
                                StackSetName=stackset_name,
                                Description='Deploys IAM roles to all sub-accounts within the AWS Organization for cross-account access.',
                                TemplateURL=template_url,
                                PermissionModel='SERVICE_MANAGED',
                                AutoDeployment={
                                    'Enabled': True,
                                    'RetainStacksOnAccountRemoval': False
                                },
                                Capabilities=['CAPABILITY_NAMED_IAM']
                            )

                            root_id = org.list_roots()['Roots'][0]['Id']

                            print("Creating stack instances...")
                            create_instances_response = cf.create_stack_instances(
                                StackSetName=stackset_name,
                                DeploymentTargets={'OrganizationalUnitIds': [root_id]},
                                Regions=['us-east-1'],
                                OperationPreferences=operation_preferences
                            )
                            operation_id = create_instances_response['OperationId']
                            print(f"Create instances operation started: {operation_id}")

                        if operation_id:
                            status = wait_for_operation(cf, stackset_name, operation_id)
                            if status == 'SUCCEEDED':
                                send_response(event, context, 'SUCCESS', {'Message': f'StackSet {request_type} operation SUCCEEDED'}, physical_resource_id=physical_resource_id)
                            else:
                                send_response(event, context, 'FAILED', {'Message': f'StackSet {request_type} operation {status}'}, physical_resource_id=physical_resource_id)
                        else:
                             send_response(event, context, 'SUCCESS', {'Message': 'StackSet is already up to date.'}, physical_resource_id=physical_resource_id)

                    elif request_type == 'Delete':
                        print("Deleting StackSet instances and then the StackSet...")
                        try:
                            paginator = cf.get_paginator('list_stack_instances')
                            pages = paginator.paginate(StackSetName=stackset_name)
                            regions = set()
                            has_instances = False
                            for page in pages:
                                if page['Summaries']:
                                    has_instances = True
                                    for instance in page['Summaries']:
                                        regions.add(instance['Region'])

                            if has_instances:
                                root_id = org.list_roots()['Roots'][0]['Id']
                                print(f"Deleting instances from root OU in regions: {list(regions)}")
                                delete_instances_response = cf.delete_stack_instances(
                                    StackSetName=stackset_name,
                                    DeploymentTargets={'OrganizationalUnitIds': [root_id]},
                                    Regions=list(regions),
                                    RetainStacks=False,
                                    OperationPreferences=operation_preferences
                                )
                                operation_id = delete_instances_response['OperationId']
                                print(f"Delete instances operation started: {operation_id}")
                                status = wait_for_operation(cf, stackset_name, operation_id)
                                if status != 'SUCCEEDED':
                                    raise Exception(f"Failed to delete stack instances, operation status: {status}")

                            print("All instances deleted. Deleting StackSet...")
                            cf.delete_stack_set(StackSetName=stackset_name)
                            print("StackSet deletion initiated.")
                            send_response(event, context, 'SUCCESS', {'Message': 'StackSet deletion initiated'}, physical_resource_id=physical_resource_id)

                        except cf.exceptions.StackSetNotFoundException:
                            print("StackSet not found, nothing to delete.")
                            send_response(event, context, 'SUCCESS', {'Message': 'StackSet not found, nothing to delete'}, physical_resource_id=physical_resource_id)

                    else:
                        send_response(event, context, 'FAILED', {'Message': f'Unknown request type: {request_type}'}, physical_resource_id=physical_resource_id)

                except Exception as e:
                    traceback.print_exc()
                    send_response(event, context, 'FAILED', {'Error': str(e)}, physical_resource_id=physical_resource_id)

  StackSetCustomResource:
    Type: Custom::StackSet
    Properties:
      ServiceToken: !GetAtt StackSetLambda.Arn
      Version: !Ref StackSetLambdaVersion

  BlocksCustomReadPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      ManagedPolicyName: !Sub '${AWS::AccountId}-BlocksCustomReadPolicy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: CeReadAll
            Effect: Allow
            Action:
              - ce:Get*
              - ce:List*
              - ce:Describe*
            Resource: "*"
          - Sid: ReservationsFullRead
            Effect: Allow
            Action:
              - ec2:DescribeReserved*
              - elasticache:DescribeReserved*
              - redshift:DescribeReserved*
              - rds:DescribeReserved*
            Resource: "*"
          - Sid: TrustedAdvisorReadAll
            Effect: Allow
            Action:      
              - trustedadvisor:Describe*
              - trustedadvisor:Get*
              - trustedadvisor:List*
              - support:DescribeTrustedAdvisorChecks
              - support:DescribeTrustedAdvisorCheckResult
              - support:DescribeTrustedAdvisorCheckSummaries
              - support:DescribeTrustedAdvisorCheckRefreshStatuses
              - support:RefreshTrustedAdvisorCheck
            Resource: "*"
          - Sid: PricingGetProducts
            Effect: Allow
            Action:
              - pricing:Describe*
              - pricing:Get*
              - pricing:List* 
            Resource: "*"
          - Sid: Ec2DescribeAll
            Effect: Allow
            Action:
              - ec2:Describe*
              - ec2:Get*
              - ec2:List*
              - ec2:SearchTransitGatewayRoutes
              - elasticloadbalancing:Describe*
              - autoscaling:Describe*
              - autoscaling:Get*
              - autoscaling:List*
            Resource: "*"
          - Sid: RdsDescribeAll
            Effect: Allow
            Action:
              - rds:Describe*
              - rds:List*
            Resource: "*"
          - Sid: ElastiCacheDescribeAll
            Effect: Allow
            Action:
              - elasticache:Describe*
              - elasticache:List*
            Resource: "*"
          - Sid: RedshiftDescribeAll
            Effect: Allow
            Action:
              - redshift:Describe*
              - redshift:List*
            Resource: "*"
          - Sid: LambdaReadAll
            Effect: Allow
            Action:
              - lambda:List*
              - lambda:Get*
            Resource: "*"
          - Sid: DynamoDbDescribeAll
            Effect: Allow
            Action:
              - dynamodb:List*
              - dynamodb:Describe*
            Resource: "*"
          - Sid: S3ReadAccess
            Effect: Allow
            Action:
              - s3:List*
              - s3:GetBucketVersioning
              - s3:GetLifecycleConfiguration
              - s3:GetBucketLogging
              - s3:GetBucketEncryption
              - s3:GetBucketTagging
              - s3:GetBucketLocation
            Resource: "*"
          - Sid: MQReadAccess
            Effect: Allow
            Action:
             - mq:Describe*
             - mq:List*
            Resource: "*"
          - Sid: EcsEksDescribeAll
            Effect: Allow
            Action:
              - ecs:List*
              - ecs:Describe*
              - eks:List*
              - eks:Describe*
            Resource: "*"
          - Sid: CloudWatchReadAll
            Effect: Allow
            Action:
              - cloudwatch:Describe*
              - cloudwatch:Get*
              - cloudwatch:List*
              - oam:ListSinks
              - logs:Describe*
              - logs:Get*
              - logs:List*
              - logs:StartQuery
              - logs:StopQuery
              - logs:TestMetricFilter
            Resource: "*"
          - Sid: CloudTrailReadAccess
            Effect: Allow
            Action:
              - cloudtrail:CancelQuery
              - cloudtrail:Describe*
              - cloudtrail:Get*
              - cloudtrail:LookupEvents
              - cloudtrail:StartQuery
              - config:DescribeConfigurationRecorderStatus
            Resource: "*"
          - Sid: CfnDescribeAll
            Effect: Allow
            Action:
              - cloudformation:Describe*
              - cloudformation:List*
              - cloudformation:Get*
              - cloudformation:DetectStackDrift
              - cloudformation:DetectStackResourceDrift
            Resource: "*"
          - Sid: SsmReadAll
            Effect: Allow
            Action:
              - ssm:Describe*
              - ssm:Get*
              - ssm:List*
            Resource: "*"
          - Sid: ConfigDescribeAll
            Effect: Allow
            Action:
              - config:Describe*
              - config:Get*
              - config:List*
              - config:Select*
              - config:BatchGet*
            Resource: "*"
          - Sid: CloudFrontReadAll
            Effect: Allow
            Action:
              - cloudfront:Get*
              - cloudfront:List*
            Resource: "*"
          - Sid: Route53ReadAll
            Effect: Allow
            Action:
              - route53:Get*
              - route53:List*
              - route53domains:Get*
              - route53domains:List*
            Resource: "*"
          - Sid: LicenseManagerReadAll
            Effect: Allow
            Action:
              - license-manager:Get*
              - license-manager:List*
            Resource: "*"
          - Sid: BackupReadAll
            Effect: Allow
            Action:
              - backup:Describe*
              - backup:Get*
              - backup:List*
            Resource: "*"
          - Sid: HealthReadAll
            Effect: Allow
            Action:
              - health:Describe*
            Resource: "*"
          - Sid: AppAutoScalingReadAll
            Effect: Allow
            Action:
              - application-autoscaling:Describe*
            Resource: "*"
          - Sid: BeanstalkReadAll
            Effect: Allow
            Action:
              - elasticbeanstalk:Describe*
              - elasticbeanstalk:List*
            Resource: "*"
          - Sid: KinesisReadAll
            Effect: Allow
            Action:
              - kinesis:Describe*
              - kinesis:List*
              - firehose:Describe*
              - firehose:List*
              - kinesisanalytics:Describe*
              - kinesisanalytics:List*
            Resource: "*"
          - Sid: MessagingReadAll
            Effect: Allow
            Action:
              - sns:Get*
              - sns:List*
              - sqs:Get*
              - sqs:List*
            Resource: "*"
          - Sid: ApiGwReadAll
            Effect: Allow
            Action:
              - apigateway:GET
            Resource: "*"
          - Sid: StepFunctionsReadAll
            Effect: Allow
            Action:
              - states:Describe*
              - states:List*
              - states:Get*
            Resource: "*"
          - Sid: GlueReadAll
            Effect: Allow
            Action:
              - glue:Get*
              - glue:List*
              - glue:BatchGet*
            Resource: "*"
          - Sid: AthenaReadAll
            Effect: Allow
            Action:
              - athena:Get*
              - athena:List*
              - athena:BatchGet*
            Resource: "*"
          - Sid: EmrReadAll
            Effect: Allow
            Action:
              - elasticmapreduce:Describe*
              - elasticmapreduce:List*
              - elasticmapreduce:View*
              - elasticmapreduce:Get*
            Resource: "*"
          - Sid: SageMakerReadAll
            Effect: Allow
            Action:
              - sagemaker:Describe*
              - sagemaker:List*
              - sagemaker:Get*
            Resource: "*"
          - Sid: OpenSearchReadAll
            Effect: Allow
            Action:
              - es:Describe*
              - es:List*
              - es:Get*
            Resource: "*"
          - Sid: WorkSpacesReadAll
            Effect: Allow
            Action:
              - workspaces:Describe*
            Resource: "*"
          - Sid: AppStreamReadAll
            Effect: Allow
            Action:
              - appstream:Describe*
              - appstream:List*
            Resource: "*"
          - Sid: FsxReadAll
            Effect: Allow
            Action:
              - fsx:Describe*
              - fsx:List*
            Resource: "*"
          - Sid: EfsReadAll
            Effect: Allow
            Action:
              - elasticfilesystem:Describe*
              - elasticfilesystem:List*
            Resource: "*"
          - Sid: StorageGatewayReadAll
            Effect: Allow
            Action:
              - storagegateway:Describe*
              - storagegateway:List*
            Resource: "*"
          - Sid: DxReadAll
            Effect: Allow
            Action:
              - directconnect:Describe*
            Resource: "*"
          - Sid: TransferReadAll
            Effect: Allow
            Action:
              - transfer:Describe*
              - transfer:List*
            Resource: "*"

  BlocksReadRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::AccountId}-Blocks-read-role'
      MaxSessionDuration: 3600
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub 'arn:${AWS::Partition}:iam::${BlocksExternalAccountId}:root'
            Action: 'sts:AssumeRole'
            Condition:
              StringEquals:
                'sts:ExternalId': !Ref ExternalId

      ManagedPolicyArns:
        - !Ref BlocksCustomReadPolicy
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSBillingReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSBudgetsReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/ServiceQuotasReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/ComputeOptimizerReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSOrganizationsReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/ResourceGroupsandTagEditorReadOnlyAccess
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSSavingsPlansReadOnlyAccess

      Policies:
        # Identity
        - PolicyName: StsWhoami
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sts:GetCallerIdentity
                Resource: "*"

        # CUR S3 Bucket Access - RESTRICTED to cur2/* prefix only
        - PolicyName: CurS3Read
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ListCurPrefix
                Effect: Allow
                Action: 's3:ListBucket'
                Resource:
                  !Sub
                    - 'arn:${AWS::Partition}:s3:::${B}'
                    - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }
                Condition:
                  StringLike:
                    s3:prefix: ['cur2/*']
              - Sid: ReadCurObjects
                Effect: Allow
                Action: 's3:GetObject'
                Resource:
                  !Sub
                    - 'arn:${AWS::Partition}:s3:::${B}/cur2/*'
                    - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }

        # KMS Decrypt for Encrypted CUR Bucket
        - !If
          - HasKms
          - PolicyName: CurKmsDecrypt
            PolicyDocument:
              Version: '2012-10-17'
              Statement:
                - Effect: Allow
                  Action:
                    - kms:Decrypt
                    - kms:DescribeKey
                  Resource: !Ref KmsKeyArn
          - !Ref 'AWS::NoValue'

Outputs:
  CURBucketName:
    Value: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName]
  CURBucketArn:
    Value:
      !Sub
        - 'arn:${AWS::Partition}:s3:::${B}'
        - { B: !If [CreateBucket, !Ref CURBucket, !Ref ExistingBucketName] }
  ExportNameOut:
    Value: !Sub '${ExportName}-${AWS::AccountId}'
  BackfillCaseId:
    Description: 'Present if Support API allowed; empty otherwise'
    Value: !GetAtt RequestBackfill.CaseId
  BlocksReadRoleArn:
    Description: 'Cross-account role to assume for S3 CUR reads, CE/Org/Budgets/Pricing/ComputeOptimizer read, and comprehensive AWS resource inventory'
    Value: !GetAtt BlocksReadRole.Arn
  BlocksReadRoleName:
    Description: 'Name of the cross-account read role'
    Value: !Ref BlocksReadRole
  ImportantNotes:
    Value: 'Deploy in us-east-1. Role includes 40+ AWS services for complete cost optimization analysis.'
